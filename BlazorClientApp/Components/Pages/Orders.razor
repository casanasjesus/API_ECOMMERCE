@page "/orders"
@rendermode InteractiveServer
@using System.ComponentModel.DataAnnotations
@using System.Net.Http
@using BlazorClientApp.Dtos
@inject BlazorClientApp.Services.IOrderApiService OrderApiService

<PageTitle>Orden</PageTitle>

<h3>@(IsEditing ? "Editar Orden" : "Nueva Orden")</h3>

<EditForm Model="orderViewModel" OnValidSubmit="SaveOrder">
    <DataAnnotationsValidator />
    <ValidationSummary />

    <div class="mb-3">
        <label class="form-label">Order Number</label>
        <InputText class="form-control" @bind-Value="orderViewModel.OrderNumber" />
    </div>

    <div class="mb-3">
        <label class="form-label">Customer</label>
        <InputText class="form-control" @bind-Value="orderViewModel.CustomerName" />
    </div>

    <div class="mb-3">
        <label class="form-label">Order Date</label>
        <InputDate class="form-control" @bind-Value="orderViewModel.OrderDate" />
    </div>

    <h5>Items</h5>

    <table class="table table-sm">
        <thead>
            <tr>
                <th>Cod. Producto</th>
                <th class="text-end">Cantidad</th>
                <th class="text-end">Precio Unitario</th>
                <th class="text-end">Sub-Total</th>
                <th></th>
            </tr>
        </thead>
        <tbody>
            @for (int i = 0; i < orderViewModel.Items.Count; i++)
            {
                var item = orderViewModel.Items[i];
                if (EditingItemIndex == i)
                {
                    <tr>
                        <td>
                            <InputText class="form-control" @bind-Value="EditingItem.ProductId" />
                            <ValidationMessage For="@(() => EditingItem.ProductId)" />
                        </td>
                        <td class="text-end">
                            <InputNumber class="form-control" @bind-Value="EditingItem.Quantity" />
                            <ValidationMessage For="@(() => EditingItem.Quantity)" />
                        </td>
                        <td class="text-end">
                            <InputNumber class="form-control" @bind-Value="EditingItem.UnitPrice" step="0.01" />
                            <ValidationMessage For="@(() => EditingItem.UnitPrice)" />
                        </td>
                        <td class="text-end">@($"{EditingItem.LineTotal:C}")</td>
                        <td>
                            <button type="button" class="btn btn-sm btn-success me-1" @onclick="() => SaveEditedItem(i)">Save</button>
                            <button type="button" class="btn btn-sm btn-secondary" @onclick="CancelEditItem">Cancel</button>
                        </td>
                    </tr>
                }
                else
                {
                    <tr>
                        <td>@item.ProductId</td>
                        <td class="text-end">@item.Quantity</td>
                        <td class="text-end">@item.UnitPrice.ToString("C")</td>
                        <td class="text-end">@item.LineTotal.ToString("C")</td>
                        <td>
                            <button type="button" class="btn btn-sm btn-outline-primary me-1" @onclick="() => BeginEditItem(i)">Edit</button>
                            <button type="button" class="btn btn-sm btn-outline-danger" @onclick="() => RemoveItem(i)">Remove</button>
                        </td>
                    </tr>
                }
            }

            // Add a new item while creating/editing order
            <tr>
                <td>
                    <InputText class="form-control" @bind-Value="NewItem.ProductId" placeholder="Product Id" />
                    <ValidationMessage For="@(() => NewItem.ProductId)" />
                </td>
                <td class="text-end">
                    <InputNumber class="form-control" @bind-Value="NewItem.Quantity" />
                    <ValidationMessage For="@(() => NewItem.Quantity)" />
                </td>
                <td class="text-end">
                    <InputNumber class="form-control" @bind-Value="NewItem.UnitPrice" step="0.01" />
                    <ValidationMessage For="@(() => NewItem.UnitPrice)" />
                </td>
                <td class="text-end">@($"{NewItem.LineTotal:C}")</td>
                <td>
                    <button type="button" class="btn btn-sm btn-primary" @onclick="AddNewItem">Add Item</button>
                </td>
            </tr>
        </tbody>
        <tfoot>
            <tr>
                <td colspan="3" class="text-end"><strong>Order Total</strong></td>
                <td class="text-end"><strong>@orderViewModel.Total.ToString("C")</strong></td>
                <td></td>
            </tr>
        </tfoot>
    </table>

    <div class="mt-3">
        <button type="submit" class="btn btn-success me-2">Save Order</button>
        <button type="button" class="btn btn-outline-secondary" @onclick="ResetForm">New</button>
        @if (IsEditing)
        {
            <button type="button" class="btn btn-danger ms-2" @onclick="DeleteOrder">Delete</button>
        }
    </div>
</EditForm>

@if (!string.IsNullOrEmpty(StatusMessage))
{
    <div class="mt-3">
        <div class="alert @(IsSuccess ? "alert-success" : "alert-danger")" role="alert">@StatusMessage</div>
    </div>
}

@code {
    // Temporary in-component view models for demo & easy copy/paste.
    // In a real app move these to separate files and use a service for persistence.

    private OrderViewModel orderViewModel { get; set; } = new();
    private OrderItemViewModel NewItem { get; set; } = new();
    private OrderItemViewModel EditingItem { get; set; } = new();
    private int? EditingItemIndex { get; set; } = null;

    private string StatusMessage { get; set; } = string.Empty;
    private bool IsSuccess { get; set; }

    // Simple flag to illustrate add vs edit mode (could be driven by query param or passed ID)
    private bool IsEditing => !string.IsNullOrWhiteSpace(orderViewModel.Id);

    protected override void OnInitialized()
    {
        // Initialize with a blank order. Replace with loading logic when editing existing order.
        ResetForm();
    }

    private void ResetForm()
    {
        orderViewModel = new OrderViewModel
        {
            Id = string.Empty,
            OrderNumber = string.Empty,
            CustomerName = string.Empty,
            OrderDate = DateTime.Today,
            Items = new System.Collections.Generic.List<OrderItemViewModel>()
        };
        NewItem = new OrderItemViewModel();
        EditingItem = new OrderItemViewModel();
        EditingItemIndex = null;
        StatusMessage = string.Empty;
    }

    private void AddNewItem()
    {
        var validationResults = new System.Collections.Generic.List<ValidationResult>();
        var ctx = new ValidationContext(NewItem);
        if (!Validator.TryValidateObject(NewItem, ctx, validationResults, true))
        {
            // Validation messages are shown by ValidationMessage components for bound fields.
            return;
        }

        // Clone NewItem to avoid it being a reference reused by the form
        orderViewModel.Items.Add(new OrderItemViewModel
        {
            ProductId = NewItem.ProductId,
            Quantity = NewItem.Quantity,
            UnitPrice = NewItem.UnitPrice
        });

        NewItem = new OrderItemViewModel();
    }

    private void BeginEditItem(int index)
    {
        EditingItemIndex = index;
        var item = orderViewModel.Items[index];
        EditingItem = new OrderItemViewModel
        {
            ProductId = item.ProductId,
            Quantity = item.Quantity,
            UnitPrice = item.UnitPrice
        };
    }

    private void SaveEditedItem(int index)
    {
        var validationResults = new System.Collections.Generic.List<ValidationResult>();
        var ctx = new ValidationContext(EditingItem);
        if (!Validator.TryValidateObject(EditingItem, ctx, validationResults, true))
        {
            return;
        }

        orderViewModel.Items[index].ProductId = EditingItem.ProductId;
        orderViewModel.Items[index].Quantity = EditingItem.Quantity;
        orderViewModel.Items[index].UnitPrice = EditingItem.UnitPrice;

        EditingItemIndex = null;
        EditingItem = new OrderItemViewModel();
    }

    private void CancelEditItem()
    {
        EditingItemIndex = null;
        EditingItem = new OrderItemViewModel();
    }

    private void RemoveItem(int index)
    {
        if (index >= 0 && index < orderViewModel.Items.Count)
        {
            orderViewModel.Items.RemoveAt(index);
            if (EditingItemIndex.HasValue && EditingItemIndex.Value == index)
            {
                CancelEditItem();
            }
        }
    }

    private async Task SaveOrder()
    {
        // Final validation for order & items
        var orderValidation = new System.Collections.Generic.List<ValidationResult>();
        var ctx = new ValidationContext(orderViewModel);
        if (!Validator.TryValidateObject(orderViewModel, ctx, orderValidation, true))
        {
            // ValidationSummary will display errors for the order fields.
            return;
        }

        // Validate items individually
        foreach (var item in orderViewModel.Items)
        {
            var itemResults = new System.Collections.Generic.List<ValidationResult>();
            var itemCtx = new ValidationContext(item);
            if (!Validator.TryValidateObject(item, itemCtx, itemResults, true))
            {
                return;
            }
        }

        // Call backend API to persist the order
        try
        {
            var orderDto = new OrderDto
            {               
                Date = orderViewModel.OrderDate,
                Total = orderViewModel.Total,
                Street = null,
                City = null,
                Number = 0,
                OrderItems = orderViewModel.Items.Select(x => new OrderItemDto()
                {
                    ProductId = int.Parse(x.ProductId),
                    ProductName = null,
                    Quantity = x.Quantity,
                    UnitPrice = x.UnitPrice,
                    Description = null
                }).ToList()
            };

            var response = await OrderApiService.SaveOrderAsync(orderDto);

            if (response.IsSuccessStatusCode)
            {
                // Optionally read response content or id returned by API
                StatusMessage = "Order saved successfully.";
                IsSuccess = true;

                // Mark as saved (demo): set Id if empty
                if (string.IsNullOrEmpty(orderViewModel.Id))
                    orderViewModel.Id = Guid.NewGuid().ToString("N");
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                StatusMessage = $"API error: {(int)response.StatusCode} {response.ReasonPhrase}. {error}";
                IsSuccess = false;
            }
        }
        catch (Exception ex)
        {
            StatusMessage = $"Request failed: {ex.Message}";
            IsSuccess = false;
        }
    }

    private void DeleteOrder()
    {
        // TODO: Call service to delete. For demo simply reset the form.
        ResetForm();
    }

    // View model definitions (move to separate files in production)
    public class OrderViewModel
    {
        public string Id { get; set; } = string.Empty;

        [Required]
        [StringLength(50)]
        public string OrderNumber { get; set; } = string.Empty;

        [Required]
        [StringLength(200)]
        public string CustomerName { get; set; } = string.Empty;

        [Required]
        public DateTime OrderDate { get; set; } = DateTime.Today;

        public System.Collections.Generic.List<OrderItemViewModel> Items { get; set; } = new();

        public decimal Total => Items?.Sum(i => i.LineTotal) ?? 0m;
    }

    public class OrderItemViewModel
    {
        [Required(AllowEmptyStrings = false)]
        public string ProductId { get; set; } = string.Empty;

        [Range(1, int.MaxValue, ErrorMessage = "Quantity must be at least 1")]
        public int Quantity { get; set; } = 1;

        [Range(0.0, double.MaxValue, ErrorMessage = "Unit price must be non-negative")]
        public decimal UnitPrice { get; set; } = 0m;

        public decimal LineTotal => Quantity * UnitPrice;
    }
}
